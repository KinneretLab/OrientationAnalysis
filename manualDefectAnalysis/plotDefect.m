function [thisImWithDefect, defPosition, defAngle] = plotDefect (thisIm, localOP, thisDefect, typeDefect, duplicateImages);
% [thisImWithDefect, defPosition, defAngle] = plotDefect (thisIm, localOP, thisDefect, typeDefect, duplicateImages);
% This function gets an image, the localOP, and the defect structure for this
% defect (which is of the format generated by ground truth app) of type
% typeDefect. The output is the exact position of the defect (determined as
% the position of the minima of the localOP in the rectangle defined by
% thisDefect), orientation of the defect in degrees based on the line
% direction in thisDefect (NOT IMPLEMENTE YET), and an thisIm overlayed with an annotation of
% this defect added.
%
% INPUT
%   thisIM - the images that the defects indicators will be overlaid on
%   localOP - the local parameter matrix which is used for detetemining the
%   exact position of the defects in the rectangle
%   thisDefect - the defect structure that is output from the groundTruth app
%   typeDefect - "one", "half", "mhalf" indicates the type of defects and
%   generate appropriate defect indication on image
%   duplicateImages - =1 if the input image contains side-by-side images
%   (in which case the defects will be plotted on both sides)
%                     =0 for single image
% OUTPUT
%   thisImWithDefect - image with defect plotted on it according to type
%   defPosition - [x,y]=[col,row] position of defect in image
%   defAngle - angle in degrees of
%% find the exact defect position within the rectangle
defRectPosition = round(thisDefect.Position); % input defect rectangle and round

if defRectPosition(1)>size(localOP,2), defRectPosition(1) = defRectPosition(1)-size(localOP,2); end % if defect is defined on second image then redefine it on first image

end1=defRectPosition(2)+defRectPosition(4); end2=defRectPosition(1)+defRectPosition(3); % find outer sides of defect

if end1>size(localOP,1), end1=size(localOP,1),end % prevent crashes if the rectangle ends outside the image by defining the end as the image boundary
if end2>size(localOP,2), end2=size(localOP,2),end

localOPRegion =  localOP (defRectPosition(2):end1, defRectPosition(1):end2); % define the localOP matrix within the rectangle
[minval,idx]=min(localOPRegion(:)); % find minima in localOP within the rectangle
[row,col]=ind2sub(size(localOPRegion), idx); row = row + defRectPosition(2); col = col + defRectPosition(1); % find index location of minima in original pixel values
defPosition = [col row]; % this contains the row and column for the position of the defect
if duplicateImages==1,
    defPosition2 = [col+size(localOP,2) row]; % this contains the row and column for the position of the defect on the second image
end
%% find defect orientation; for now we're not doing anything with it; but for later
if or(strcmp(typeDefect,'half'),strcmp(typeDefect,'mhalf')), % defect types which have an orientation
    try % look for defect direction
        defLine=thisDefect.dir.Position; % now determine defect orientation
        slope = -(defLine(2,2) - defLine(1,2)) ./ (defLine(2,1) - defLine(1,1)); % slope = - deltay/deltax; the minus sign is because the axis image reflect the y-axis
        defAngle = atand(slope); if defAngle<0, defAngle=defAngle+180; end % map the defect in degrees to be between 0 and 180
    catch
        defAngle=NaN; % no dir was associated with this defect
    end
else
    defAngle=NaN; % one defect have no orientation so put as NaN
end

%% define defect plot position and size
markerSize = 32; % size of marked square around defects
cicrleSize = 6; % size of circle at the core of the defect
lineWidth=2; opacity=0.5; % linewidth for square, opacity for circle in core

% this is for the plotting the defect on the quiver image
rectCorner=defPosition-0.5*[2*markerSize,2*markerSize];  % defines a rectangle of size 2 * markerSize, 2 * markersize
position = [rectCorner,2*markerSize,2*markerSize ];
positionc = [defPosition,cicrleSize ]; % draws a circle of radius cicrleSize around the defect position
% this is for the defect on the second image
if duplicateImages==1,
    rectCorner2=defPosition2-0.5*[2*markerSize,2*markerSize];  % draws a rectangle of sides markerSize, 2* markersize
    position2 = [rectCorner2,2*markerSize,2*markerSize ];
    positionc2 = [defPosition2,cicrleSize ]; % draws a circle of radius cicrleSize around the defect position
end

%% determine defect color by type ( use different colors for different defect types)
colorList= {'cyan','magenta',[1 0.5 0]}; % Plot defect acording to color scheme: cyan - +1/2; magenta -1/2 ; orange +1;
% colorList= {'cyan','magenta',[1 0.5 0],'red','blue','green', 'black', 'white'}; % this defines the color of defects
if strcmp(typeDefect,'one') % one defects
    label = 3; % this puts a label for one defects=3
    %     thisImWithDefect = insertObjectAnnotation(thisIm,'circle',position,label,'LineWidth',3,'Color',colorList{label},'TextColor','black');
    %     thisImWithDefect = insertObjectAnnotation(thisIm,'rectangle',position,label,'LineWidth',3,'Color',colorList{label},'TextColor','black');
end

if strcmp(typeDefect,'half') % half defects
    label = 1; % this puts a label for half defects=1
end

if strcmp(typeDefect,'mhalf') % minus half defects
    label = 2; % this puts a label for minus half defects=1
end

%% now add an annotation of the defect on image;
thisImWithDefect = insertShape(thisIm,'rectangle',position,'color',colorList{label},'linewidth',lineWidth);
thisImWithDefect = insertShape(thisImWithDefect,'FilledCircle',positionc,'color',colorList{label},'opacity',opacity);
if duplicateImages==1, % if we have a second image
    thisImWithDefect = insertShape(thisImWithDefect,'rectangle',position2,'color',colorList{label},'linewidth',lineWidth);
    thisImWithDefect = insertShape(thisImWithDefect,'FilledCircle',positionc2,'color',colorList{label},'opacity',opacity);
end

%     figure; imshow(thisImWithDefect)
end
