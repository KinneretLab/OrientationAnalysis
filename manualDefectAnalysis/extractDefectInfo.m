function [ defPosition, defAngle] = extractDefectInfo (localOP, thisDefect, typeDefect)
% 
% This function gets the defect structure for this
% defect (which is of the format generated by ground truth app) of type
% typeDefect. The output is the exact position of the defect (determined as
% the position of the minima of the localOP in the rectangle defined by
% thisDefect), orientation of the defect in degrees based on the line
% direction in thisDefect (NOT IMPLEMENTE YET).
%
% INPUT
%   localOP - the local parameter matrix which is used for detetemining the
%   exact position of the defects in the rectangle
%   thisDefect - the defect structure that is output from the groundTruth app
%   typeDefect - "one", "half", "mhalf" indicates the type of defects and
%   generate appropriate defect indication on image
%   duplicateImages - =1 if the input image contains side-by-side images
%   (in which case the defects will be plotted on both sides)
%                     =0 for single image
% OUTPUT
%   defPosition - [x,y]=[col,row] position of defect in image
%   defAngle - angle in degrees of
%% find the exact defect position within the rectangle
defRectPosition = round(thisDefect.Position); % input defect rectangle and round

if defRectPosition(1)>size(localOP,2), defRectPosition(1) = defRectPosition(1)-size(localOP,2); end % if defect is defined on second image then redefine it on first image

end1=defRectPosition(2)+defRectPosition(4); end2=defRectPosition(1)+defRectPosition(3); % find outer sides of defect

if end1>size(localOP,1), end1=size(localOP,1),end % prevent crashes if the rectangle ends outside the image by defining the end as the image boundary
if end2>size(localOP,2), end2=size(localOP,2),end

localOPRegion =  localOP (defRectPosition(2):end1, defRectPosition(1):end2); % define the localOP matrix within the rectangle
[minval,idx]=min(localOPRegion(:)); % find minima in localOP within the rectangle
[row,col]=ind2sub(size(localOPRegion), idx); row = row + defRectPosition(2); col = col + defRectPosition(1); % find index location of minima in original pixel values
defPosition = [col row]; % this contains the row and column for the position of the defect

%% find defect orientation; for now we're not doing anything with it; but for later
if or(strcmp(typeDefect,'half'),strcmp(typeDefect,'mhalf')), % defect types which have an orientation
    try % look for defect direction
        defLine=thisDefect.dir.Position; % now determine defect orientation
        slope = -(defLine(2,2) - defLine(1,2)) ./ (defLine(2,1) - defLine(1,1)); % slope = - deltay/deltax; the minus sign is because the axis image reflect the y-axis
        defAngle = atand(slope); if defAngle<0, defAngle=defAngle+180; end % map the defect in degrees to be between 0 and 180
    catch
        defAngle=NaN; % no dir was associated with this defect
    end
else
    defAngle=NaN; % one defect have no orientation so put as NaN
end


end
